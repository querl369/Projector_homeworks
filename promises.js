
// Є наступний код:
console.log('start');

const promise1 = new Promise((resolve, reject) => {
console.log(1)
resolve(2)
})

promise1.then(res => {
console.log(res)
})

console.log('end');

// Яким буде результат його виклику? Чому? Опишіть як працює цей код.

/*
У цьому коді створюється об'єкт Promise - `promise1`, 
який має функцію-виконавця (executor function) яка приймає 
два параметри: `resolve` і `reject`. В даному випадку, функція-виконавець 
виводить число 1 у консоль і викликає `resolve(2)`, передаючи
число 2 як результат обіцянки. Після створення `promise1`, викликається
метод `then()` на об'єкті `promise1`. `then()` приймає функцію 
з одним параметром (`res`), яка виводить значення `res` у консоль.
При виконанні коду, спочатку виводиться рядок "start". Потім створюється 
`promise1` і виводиться число 1. Далі, виконується метод `then()` на 
`promise1`, але цей метод не виконується відразу. Виконання `then()` 
відбувається асинхронно, після завершення поточного циклу подій (event loop).
Тому, після створення `promise1` і передачі числа 2 в `resolve()`, виконання 
коду продовжується і виводиться рядок "end". Потім, коли стек викликів 
порожній, event loop отримує повідомлення про те, що `promise1` 
виконано, і запускає відповідний обробник (handler) з методу `then()`. 
Цей обробник отримує число 2 як значення `res` і виводить його у консоль.

Отже, результат виклику буде:

start
1
end
2

*/

// 2. Є наступний код:
Promise.resolve(1)
		.then((x) => x + 1)
		.then((x) => { throw new Error('My Error') })
		.catch(() => 1)
		.then((x) => x + 1)
		.then((x) => console.log(x))
		.catch(console.error)
// Яким буде результат його виклику? Чому? Опишіть як працює цей код.

/*
Пояснення роботи коду:

Promise.resolve(1) створює об'єкт Promise, який одразу вирішується з значенням 1.

Перший then((x) => x + 1) отримує результат 1 і додає до нього 1, отримуючи 2.

Другий then((x) => { throw new Error('My Error') }) отримує результат 2 і викликає помилку throw new Error('My Error'). Це призводить до переходу до найближчого блоку catch().

catch(() => 1) перехоплює помилку та повертає значення 1.

Наступний then((x) => x + 1) отримує результат 1 і додає до нього 1, отримуючи 2.

Останній then((x) => console.log(x)) отримує результат 2 і виводить його у консоль.

Таким чином, результат виклику буде:

2
*/





// Є наступний код:
const promise = new Promise(res => res(2));
	promise.then(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .then(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .finally(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .then(v => {
	        console.log(v);
	    });
// Яким буде результат його виклику? Чому? Опишіть як працює цей код.
/*	    
Пояснення роботи коду:

Створюється об'єкт Promise за допомогою конструктора Promise, і він одразу вирішується значенням 2, переданим у функцію res.

Перший then отримує результат 2 і виводить його у консоль. Потім повертає результат v * 2 (4).

Другий then отримує результат 4 і виводить його у консоль. Потім повертає результат v * 2 (8).

finally не отримує параметрів та не впливає на результати попередніх обробників. Вона виконується незалежно від того, чи було викликано resolve, чи reject. У цьому випадку, вона виводить undefined у консоль, оскільки поверненого значення немає.

Останній then отримує результат 8 (повернутий з другого then) і виводить його у консоль.

Отже, результат виклику буде:

2
4
undefined
8
*/